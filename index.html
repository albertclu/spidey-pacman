<!DOCTYPE html>
<html lang="en">
    <head>
         <meta charset="UTF-8">
         <title>Spiderman vs Villains - 5 Levels</title>
     <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
     <style>
           * {
                  box-sizing: border-box;
           }
           html, body {
                  margin: 0;
                  padding: 0;
                  width: 100%;
                  height: 100%;
           }
           body {
                  background-color: #000;
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  min-height: 100vh;
                  font-family: 'Courier New', Courier, monospace;
           }
           #game-container {
                  position: relative;
                  width: 766px;
                  height: 680px;
           }
           canvas {
                  display: block;
                  image-rendering: pixelated;
           }
           .ui-screen {
                  position: fixed;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background: rgba(0,0,0,0.85);
                  display: flex;
                  flex-direction: column;
                  justify-content: center;
                  align-items: center;
                  color: white;
                  text-align: center;
                  z-index: 10;
           }
           h1 {
                  font-size: 42px;
                  margin-bottom: 10px;
                  animation: pulse 1.5s infinite;
           }
           p {
                  font-size: 18px;
                  line-height: 1.6;
           }
           button {
                  padding: 15px 30px;
                  font-size: 20px;
                  background: #e23636;
                  color: white;
                  border: none;
                  cursor: pointer;
                  border-radius: 5px;
                  margin-top: 10px;
           }
           button:hover {
                  background: #b11313;
           }
           .hidden {
                  display: none !important;
           }
           .congratulations-image {
                  width: 150px;
                  height: 150px;
                  margin: 20px 0;
                  animation: bounce 1s infinite;
           }
           .thumbs-up {
                  font-size: 60px;
                  animation: spin 2s infinite linear;
           }
           @keyframes pulse {
                  0%, 100% { transform: scale(1); }
                  50% { transform: scale(1.1); }
           }
           @keyframes bounce {
                  0%, 100% { transform: translateY(0); }
                  50% { transform: translateY(-20px); }
           }
           @keyframes spin {
                  0% { transform: rotate(0deg); }
                  100% { transform: rotate(360deg); }
           }
          </style>
    </head>
    <body>
         <div id="game-container"></div>div>

         <div id="start-screen" class="ui-screen">
               <h1 style="color:#e23636;">SPIDERMAN GAME</h1>h1>
               <p>Collect all the yellow dots and avoid the villains!<br>Use arrow keys to move.<br>5 Levels with increasing difficulty!</p>
           <button onclick="startGame()">PLAY GAME</button>button>
         </div>div>
    
     <div id="level-complete-screen" class="ui-screen hidden">
       <h1 style="color:#f0d000;">LEVEL COMPLETE!</h1>h1>
       <p id="level-info" style="font-size:24px; margin:10px 0;"></p>
       <p id="level-score" style="font-size:20px; margin:10px 0;"></p>
       <button onclick="nextLevel()">NEXT LEVEL</button>button>
     </div>div>
    
     <div id="game-over-screen" class="ui-screen hidden">
       <h1 style="color:#e23636;">GAME OVER</h1>h1>
       <p>Spidey got caught!</p>
       <p id="final-score"></p>
       <button onclick="location.reload()">TRY AGAIN</button>button>
     </div>div>
    
     <div id="congratulations-screen" class="ui-screen hidden">
       <h1 style="color:#f0d000;">YOU WON ALL 5 LEVELS!</h1>h1>
       <p style="font-size:24px; margin:10px 0;">You have beaten the Spidey Pac-Man Game!!!</p>
       <img src="Assets/spiderman.png" alt="Spiderman" class="congratulations-image" style="filter: drop-shadow(0 0 10px #e23636);">
       <p style="font-size:20px;">üéâ <span class="thumbs-up">üëç</span>span> üéâ</p>
       <p id="win-score" style="font-size:20px; color:#f0d000; margin:20px 0;"></p>
       <button onclick="location.reload()">PLAY AGAIN</button>button>
     </div>div>
    
     <script>
           const T = 34;
           const OFF = 17;
           const COLS = 19;
           const ROWS = 19;
           const TUNNEL_ROW = 9;
           const TUNNEL_W = 60;
           const CANVAS_W = COLS * T + TUNNEL_W * 2;
           const CANVAS_H = ROWS * T + 34;
           const PLAYER_SPEED = 150;
           const BASE_VILLAIN_SPEED = 110;

           const tpx = (col, row) => ({ x: col * T + OFF + TUNNEL_W, y: row * T + OFF });

           // 5 Different maze layouts
           const mazeLevels = [
                  // Level 1 - Original
                  [
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
                          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                          [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1],
                          [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0],
                          [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                          [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
                          [1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1],
                          [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
                          [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                          [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
                          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                          [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                         ],
                  // Level 2 - More walls
                  [
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1],
                          [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
                          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                          [1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1],
                          [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
                          [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1],
                          [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
                          [1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1],
                          [1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                          [1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1],
                          [1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1],
                          [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                         ],
                  // Level 3 - Even more walls
                  [
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],
                          [1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1],
                          [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
                          [1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1],
                          [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
                          [1,0,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1],
                          [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
                          [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],
                          [1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                          [1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1],
                          [1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1],
                          [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                         ],
                  // Level 4 - Tight maze
                  [
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],
                          [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                          [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
                          [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
                          [1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],
                          [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                          [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                         ],
                  // Level 5 - Ultimate challenge
                  [
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
                          [1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1],
                          [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
                          [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
                          [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                          [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
                          [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
                          [1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],
                          [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                          [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
                          [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
                          [1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1],
                          [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                         ]
                 ];

           let currentLevel = 0;
           let score = 0;
           let highScore = parseInt(localStorage.getItem('spideyHighScore') || '0');
           let scoreText, highScoreText;
           let gameActive = false;
           let mazeLayout = mazeLevels[0];

           const config = {
                  type: Phaser.AUTO,
                  width: CANVAS_W,
                  height: CANVAS_H,
                  parent: 'game-container',
                  backgroundColor: '#000011',
                  render: {
                          transparent: true,
                          pixelArt: true,
                          antialias: false
                  },
                  scene: { preload, create, update }
           };

           function preload() {
                  this.load.on('loaderror', () => {});
                  this.load.image('spiderman', 'Assets/spiderman.png');
                  this.load.image('kingpin', 'Assets/kingpin.png');
                  this.load.image('goblin', 'Assets/goblin.png');
                  this.load.image('doc-ock', 'Assets/doc-ock.png');
                  this.load.image('venom', 'Assets/venom.png');
                  this.load.image('wall', 'Assets/wall.png');
           }

           function ensureTexture(scene, key, color, w, h, circle = false) {
                  if (scene.textures.exists(key)) return;
                  const g = scene.add.graphics();
                  g.fillStyle(color, 1);
                  if (circle) g.fillCircle(w / 2, h / 2, w / 2);
                  else g.fillRect(0, 0, w, h);
                  g.generateTexture(key, w, h);
                  g.destroy();
           }

           function isWall(col, row) {
                  if (row === TUNNEL_ROW && (col < 0 || col >= COLS)) return false;
                  if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return true;
                  return mazeLayout[row][col] === 1;
           }

           const ALL_DIRS = [
               { dx: 1, dy: 0 },
               { dx: -1, dy: 0 },
               { dx: 0, dy: 1 },
               { dx: 0, dy: -1 },
                 ];

           function openDirs(col, row) {
                  return ALL_DIRS.filter(d => !isWall(col + d.dx, row + d.dy));
           }

           function create() {
                  ensureTexture(this, 'wall', 0x2244cc, T, T);
                  ensureTexture(this, 'spiderman', 0xe23636, 30, 30, true);
                  ensureTexture(this, 'kingpin', 0xdddddd, 30, 30, true);
                  ensureTexture(this, 'goblin', 0x00cc00, 30, 30, true);
                  ensureTexture(this, 'doc-ock', 0xff8800, 30, 30, true);
                  ensureTexture(this, 'venom', 0xaa00ee, 30, 30, true);

                  this.webMap = {};
                  if (this.textures.exists('web')) this.textures.remove('web');
                  const gWeb = this.add.graphics();
                  gWeb.fillStyle(0xffee00, 1.0);
                  gWeb.fillCircle(6, 6, 6);
                  gWeb.generateTexture('web', 12, 12);
                  gWeb.destroy();

                  mazeLayout.forEach((row, ry) => {
                          row.forEach((cell, cx) => {
                                   const pos = tpx(cx, ry);
                                   if (cell === 1) {
                                             this.add.image(pos.x, pos.y, 'wall').setDisplaySize(T, T);
                                   } else {
                                             const w = this.add.image(pos.x, pos.y, 'web').setDisplaySize(10, 10);
                                             this.webMap[`${cx},${ry}`] = w;
                                   }
                          });
                  });

                  const sp = tpx(9, 14);
                  this.player = {
                          sprite: this.add.image(sp.x, sp.y, 'spiderman').setDisplaySize(30, 30),
                          x: sp.x, y: sp.y, col: 9, row: 14,
                          dx: 0, dy: 0, ndx: 0, ndy: 0,
                          progress: 0, moving: false
                  };

                  // Create villains based on level
                  const levelVillainCount = [4, 5, 6, 7, 8][currentLevel];
                  const villainDefs = [
                      { key: 'kingpin', col: 2, row: 1 },
                      { key: 'goblin', col: 7, row: 3 },
                      { key: 'doc-ock', col: 11, row: 3 },
                      { key: 'venom', col: 16, row: 1 },
                      { key: 'kingpin', col: 4, row: 7 },
                      { key: 'goblin', col: 14, row: 7 },
                      { key: 'doc-ock', col: 9, row: 15 },
                      { key: 'venom', col: 8, row: 8 }
                         ].slice(0, levelVillainCount);

                  this.villains = villainDefs.map(({ key, col, row }) => {
                          const pos = tpx(col, row);
                          const dirs = openDirs(col, row);
                          const d = dirs[Math.floor(Math.random() * dirs.length)] || { dx: 1, dy: 0 };
                          return {
                                   sprite: this.add.image(pos.x, pos.y, key).setDisplaySize(30, 30),
                                   x: pos.x, y: pos.y, col, row, dx: d.dx, dy: d.dy,
                                   progress: 0, moving: false
                          };
                  });

                  const barY = ROWS * T + 17;
                  scoreText = this.add.text(20, barY, 'Score: 0', { fontSize: '18px', fill: '#fff' }).setOrigin(0, 0.5);
                  highScoreText = this.add.text(CANVAS_W-20, barY, 'Best: ' + highScore, { fontSize: '18px', fill: '#fff' }).setOrigin(1, 0.5);
                  const levelText = this.add.text(CANVAS_W/2, barY, 'Level: ' + (currentLevel + 1), { fontSize: '18px', fill: '#f0d000' }).setOrigin(0.5, 0.5);

                  this.cursors = this.input.keyboard.createCursorKeys();
                  this.gameOver = false;
           }

           function advanceActor(actor, speedTiles, delta, chooseNext) {
                  if (!actor.moving) return;
                  actor.progress += speedTiles * delta;
                  if (actor.progress >= 1) {
                          actor.col += actor.dx;
                          actor.row += actor.dy;
                          actor.col = ((actor.col % COLS) + COLS) % COLS;
                          actor.row = Math.max(0, Math.min(ROWS - 1, actor.row));
                          actor.progress -= 1;
                          const next = chooseNext(actor);
                          if (next) {
                                   actor.dx = next.dx;
                                   actor.dy = next.dy;
                          } else {
                                   actor.dx = 0;
                                   actor.dy = 0;
                                   actor.moving = false;
                          }
                  }
                  const from = tpx(actor.col, actor.row);
                  let toX, toY;
                  const nextCol = actor.col + actor.dx;
                  const nextRow = actor.row + actor.dy;
                  if (nextCol < 0) {
                          toX = 0;
                          toY = from.y;
                  } else if (nextCol >= COLS) {
                          toX = CANVAS_W;
                          toY = from.y;
                  } else {
                          const to = tpx(nextCol, nextRow);
                          toX = to.x;
                          toY = to.y;
                  }
                  actor.x = from.x + (toX - from.x) * actor.progress;
                  actor.y = from.y + (toY - from.y) * actor.progress;
                  actor.sprite.x = actor.x;
                  actor.sprite.y = actor.y;
           }

           function playerNextDir(player) {
                  if ((player.ndx !== 0 || player.ndy !== 0) && !isWall(player.col + player.ndx, player.row + player.ndy)) {
                          const d = { dx: player.ndx, dy: player.ndy };
                          player.ndx = 0;
                          player.ndy = 0;
                          return d;
                  }
                  if ((player.dx !== 0 || player.dy !== 0) && !isWall(player.col + player.dx, player.row + player.dy)) {
                          return { dx: player.dx, dy: player.dy };
                  }
                  return null;
           }

           function bfsNextDir(startCol, startRow, targetCol, targetRow) {
                  if (startCol === targetCol && startRow === targetRow) return null;
                  const visited = new Set();
                  const queue = [{ col: startCol, row: startRow, firstDir: null }];
                  visited.add(`${startCol},${startRow}`);
                  while (queue.length > 0) {
                          const { col, row, firstDir } = queue.shift();
                          for (const d of ALL_DIRS) {
                                   const nc = col + d.dx;
                                   const nr = row + d.dy;
                                   const key = `${nc},${nr}`;
                                   if (isWall(nc, nr) || visited.has(key)) continue;
                                   visited.add(key);
                                   const step = firstDir || d;
                                   if (nc === targetCol && nr === targetRow) return step;
                                   queue.push({ col: nc, row: nr, firstDir: step });
                          }
                  }
                  return null;
           }

           function villainNextDir(villain, playerCol, playerRow) {
                  const chase = bfsNextDir(villain.col, villain.row, playerCol, playerRow);
                  if (chase) return chase;
                  const open = openDirs(villain.col, villain.row);
                  const nonReverse = open.filter(d => !(d.dx === -villain.dx && d.dy === -villain.dy));
                  const choices = nonReverse.length > 0 ? nonReverse : open;
                  return choices.length > 0 ? choices[Math.floor(Math.random() * choices.length)] : null;
           }

           function update(time, deltaMs) {
                  if (!gameActive || this.gameOver) return;
                  const delta = Math.min(deltaMs / 1000, 0.05);

                  const c = this.cursors;
                  if (c.left.isDown) { this.player.ndx = -1; this.player.ndy = 0; }
                  else if (c.right.isDown) { this.player.ndx = 1; this.player.ndy = 0; }
                  else if (c.up.isDown) { this.player.ndx = 0; this.player.ndy = -1; }
                  else if (c.down.isDown) { this.player.ndx = 0; this.player.ndy = 1; }

                  const p = this.player;
                  if (!p.moving && (p.ndx !== 0 || p.ndy !== 0)) {
                          if (!isWall(p.col + p.ndx, p.row + p.ndy)) {
                                   p.dx = p.ndx;
                                   p.dy = p.ndy;
                                   p.ndx = 0;
                                   p.ndy = 0;
                                   p.moving = true;
                          }
                  }

                  advanceActor(p, PLAYER_SPEED / T, delta, playerNextDir);

                  if (p.progress < (PLAYER_SPEED / T) * delta + 0.05) {
                          const key = `${p.col},${p.row}`;
                          if (this.webMap[key]) {
                                   this.webMap[key].destroy();
                                   delete this.webMap[key];
                                   score += 10;
                                   scoreText.setText('Score: ' + score);
                                   if (score > highScore) {
                                             highScore = score;
                                             highScoreText.setText('Best: ' + highScore);
                                             localStorage.setItem('spideyHighScore', highScore);
                                   }
                                   if (Object.keys(this.webMap).length === 0) {
                                             endLevel(this);
                                             return;
                                   }
                          }
                  }

                  const pCol = p.col, pRow = p.row;
                  const villainSpeed = BASE_VILLAIN_SPEED * Math.pow(1.02, currentLevel);
                  for (const v of this.villains) {
                          if (!v.moving) {
                                   const next = villainNextDir(v, pCol, pRow);
                                   if (next) {
                                             v.dx = next.dx;
                                             v.dy = next.dy;
                                             v.moving = true;
                                   }
                          }
                          advanceActor(v, villainSpeed / T, delta, (actor) => villainNextDir(actor, pCol, pRow));
                  }

                  for (const v of this.villains) {
                          if (Phaser.Math.Distance.Between(p.x, p.y, v.x, v.y) < 18) {
                                   endGame(this, false);
                                   return;
                          }
                  }
           }

           function endLevel(scene) {
                  scene.gameOver = true;
                  gameActive = false;
                  document.getElementById('level-info').textContent = 'Level ' + (currentLevel + 1) + ' Complete!';
                  document.getElementById('level-score').textContent = 'Score: ' + score;
                  if (currentLevel < 4) {
                          document.getElementById('level-complete-screen').classList.remove('hidden');
                  } else {
                          document.getElementById('win-score').textContent = 'Final Score: ' + score;
                          document.getElementById('congratulations-screen').classList.remove('hidden');
                  }
           }

           function endGame(scene, won) {
                  scene.gameOver = true;
                  gameActive = false;
                  document.getElementById('final-score').textContent = 'Score: ' + score;
                  document.getElementById('game-over-screen').classList.remove('hidden');
           }

           function startGame() {
                  document.getElementById('start-screen').classList.add('hidden');
                  const scene = game.scene.scenes[0];
                  scene.villains.forEach(v => { v.moving = true; });
                  gameActive = true;
           }

           function nextLevel() {
                  document.getElementById('level-complete-screen').classList.add('hidden');
                  currentLevel++;
                  mazeLayout = mazeLevels[currentLevel];
                  game.scene.stop();
                  game.scene.start();
           }

           const game = new Phaser.Game(config);
     </script>
    </body>
</html>html>
     </script></p></p>
    </body>
     </style></title>
    </head>
